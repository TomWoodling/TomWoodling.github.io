<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SYNTHWAVE CRUISER</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #0a0014; font-family: 'Rajdhani', sans-serif; cursor: none; }
  canvas { display: block; }
  #hud { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 40px; align-items: flex-end; pointer-events: none; z-index: 10; }
  .hud-panel { background: rgba(0,0,0,0.4); border: 1px solid rgba(0,255,255,0.3); border-radius: 8px; padding: 12px 24px; backdrop-filter: blur(10px); text-align: center; }
  .hud-label { font-family: 'Rajdhani', sans-serif; font-size: 11px; font-weight: 300; color: rgba(0,255,255,0.6); text-transform: uppercase; letter-spacing: 3px; margin-bottom: 2px; }
  .hud-value { font-family: 'Orbitron', monospace; font-size: 28px; font-weight: 700; color: #00ffff; text-shadow: 0 0 20px rgba(0,255,255,0.5), 0 0 40px rgba(0,255,255,0.2); }
  #biome-name { font-family: 'Orbitron', monospace; font-size: 14px; color: #ff00ff; text-shadow: 0 0 20px rgba(255,0,255,0.5); }
  #title-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; background: radial-gradient(ellipse at center, rgba(10,0,20,0.8) 0%, rgba(10,0,20,0.98) 100%); transition: opacity 1.5s ease; }
  #title-overlay.hidden { opacity: 0; pointer-events: none; }
  #title-overlay h1 { font-family: 'Orbitron', monospace; font-size: 52px; font-weight: 900; color: #00ffff; text-shadow: 0 0 40px rgba(0,255,255,0.6), 0 0 80px rgba(0,255,255,0.3), 0 0 120px rgba(255,0,255,0.2); letter-spacing: 12px; margin-bottom: 20px; }
  #title-overlay p { font-family: 'Rajdhani', sans-serif; font-size: 18px; color: rgba(255,0,255,0.7); letter-spacing: 6px; text-transform: uppercase; animation: pulse 2s ease-in-out infinite; }
  @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
  #vignette { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 5; background: radial-gradient(ellipse at center, transparent 50%, rgba(10,0,20,0.6) 100%); }
  #scanlines { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 6; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px); }
  #biome-transition { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); font-family: 'Orbitron', monospace; font-size: 36px; font-weight: 900; letter-spacing: 8px; pointer-events: none; z-index: 15; opacity: 0; transition: opacity 0.8s ease; text-shadow: 0 0 40px currentColor, 0 0 80px currentColor; }
  #biome-transition.show { opacity: 1; }
  #volume-control { position: fixed; top: 20px; right: 20px; z-index: 20; display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.4); border: 1px solid rgba(0,255,255,0.3); border-radius: 8px; padding: 8px 14px; backdrop-filter: blur(10px); cursor: pointer; }
  #volume-control span { font-family: 'Rajdhani', sans-serif; font-size: 12px; color: rgba(0,255,255,0.6); letter-spacing: 2px; }
  #vol-slider { -webkit-appearance: none; width: 80px; height: 3px; background: rgba(0,255,255,0.2); border-radius: 2px; outline: none; cursor: pointer; }
  #vol-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #00ffff; border-radius: 50%; box-shadow: 0 0 10px rgba(0,255,255,0.5); }
  #debug-log { position: fixed; top: 20px; left: 20px; z-index: 50; font-family: 'Rajdhani', monospace; font-size: 12px; color: #00ff88; pointer-events: none; max-width: 400px; line-height: 1.6; text-shadow: 0 0 5px rgba(0,255,0,0.3); }
  #debug-log .err { color: #ff4444; }
  #debug-log .ok { color: #00ff88; }
  #debug-log .warn { color: #ffaa00; }
</style>
</head>
<body>
<div id="title-overlay"><h1>SYNTHWAVE CRUISER</h1><p>Press any key to drive</p></div>
<div id="vignette"></div>
<div id="scanlines"></div>
<div id="biome-transition"></div>
<div id="debug-log"></div>
<div id="volume-control"><span>VOL</span><input type="range" id="vol-slider" min="0" max="1" step="0.05" value="0.5"></div>
<div id="hud">
  <div class="hud-panel"><div class="hud-label">Speed</div><div class="hud-value"><span id="speed-val">0</span> <span style="font-size:14px;opacity:0.6">KPH</span></div></div>
  <div class="hud-panel"><div class="hud-label">Zone</div><div id="biome-name">COUNTRYSIDE</div></div>
  <div class="hud-panel"><div class="hud-label">Distance</div><div class="hud-value"><span id="dist-val">0.0</span> <span style="font-size:14px;opacity:0.6">KM</span></div></div>
</div>

<script>
// Debug logger visible on screen
const debugEl = document.getElementById('debug-log');
const debugLines = [];
function dbg(msg, type='ok') {
  console.log('[SYNTH] ' + msg);
  debugLines.push(`<span class="${type}">${msg}</span>`);
  if (debugLines.length > 8) debugLines.shift();
  debugEl.innerHTML = debugLines.join('<br>');
}
</script>

<!-- Three.js r128 via CDN (non-module for broader compat) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Official GLTFLoader from three.js examples CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
dbg('Three.js loaded: r' + THREE.REVISION);

// ═══ CONFIG ═══
const C = { roadWidth:12, chunkLength:60, visibleChunks:14, maxSpeed:120, accel:35, brake:60, friction:15,
  steerSpeed:2.2, steerReturn:3.0, maxSteer:0.8, camSmoothPos:3.0, camSmoothLook:5.0, camH:4.5, camDist:9, biomeDur:45 };

// ═══ BIOMES ═══
const BIOMES = {
  countryside:{name:'COUNTRYSIDE',fogColor:new THREE.Color(0x050010),skyColor:new THREE.Color(0x0a0014),neonP:new THREE.Color(0x00ff88),neonS:new THREE.Color(0x00ffff),music:'synth-country.mp3'},
  city:{name:'NEON CITY',fogColor:new THREE.Color(0x0a0020),skyColor:new THREE.Color(0x0f0025),neonP:new THREE.Color(0xff00ff),neonS:new THREE.Color(0xff4488),music:'synth-city.mp3'},
  beach:{name:'NEON BEACH',fogColor:new THREE.Color(0x000a1a),skyColor:new THREE.Color(0x000a18),neonP:new THREE.Color(0xff8800),neonS:new THREE.Color(0xffaa00),music:'synth-beach.mp3'},
};
const biomeOrder = ['countryside','city','beach'];

// ═══ AUDIO ═══
const audio = {
  tracks:{}, current:null, masterVol:0.5, fadeDur:3, ready:false,
  init(){
    if(this.ready)return; this.ready=true; dbg('Audio system init');
    biomeOrder.forEach(k=>{
      const url = BIOMES[k].music;
      dbg('Loading audio: ' + url, 'warn');
      const a=new Audio(url); a.loop=true; a.volume=0; a.preload='auto';
      this.tracks[k]={el:a,target:0,cur:0,ok:false};
      a.addEventListener('canplaythrough',()=>{ this.tracks[k].ok=true; dbg('Audio ready: '+url); });
      a.addEventListener('error',(e)=>{ dbg('Audio FAILED: '+url+' ('+( a.error ? a.error.message : 'unknown')+')', 'err'); });
    });
  },
  switchTo(k){
    if(!this.ready)return;
    var isNew = this.current!==k;
    if(isNew) dbg('Music -> '+BIOMES[k].name);
    biomeOrder.forEach(b=>{const t=this.tracks[b];
      if(b===k){t.target=this.masterVol;if(t.ok&&t.el.paused){t.el.currentTime=0;t.el.play().catch(e=>dbg('Play err: '+e.message,'err'));}}
      else t.target=0;});
    this.current=k;
  },
  // Called by retry loop — forces play attempt even if current matches
  retryPlay(k){
    if(!this.ready)return false;
    var t=this.tracks[k];
    if(!t||!t.ok)return false;
    t.target=this.masterVol;
    if(t.el.paused){t.el.currentTime=0;t.el.play().catch(e=>dbg('Play err: '+e.message,'err'));}
    return true;
  },
  update(dt){
    if(!this.ready)return;const r=1/this.fadeDur;
    biomeOrder.forEach(k=>{const t=this.tracks[k];if(!t.ok)return;
      if(t.cur<t.target)t.cur=Math.min(t.cur+r*dt,t.target);
      else if(t.cur>t.target)t.cur=Math.max(t.cur-r*dt,0);
      t.el.volume=t.cur;if(t.cur<=0&&!t.el.paused)t.el.pause();});
  },
  setVol(v){this.masterVol=v;if(this.current)this.tracks[this.current].target=v;}
};
document.getElementById('vol-slider').addEventListener('input',e=>audio.setVol(parseFloat(e.target.value)));

// ═══ RENDERER ═══
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.prepend(renderer.domElement);
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050010,0.012);
scene.background = new THREE.Color(0x0a0014);
const camera = new THREE.PerspectiveCamera(65,window.innerWidth/window.innerHeight,0.5,500);

// ═══ NEON SHADER ═══
const nVS=`varying vec3 vWP,vN,vV;void main(){vec4 w=modelMatrix*vec4(position,1.0);vWP=w.xyz;vN=normalize(normalMatrix*normal);vV=normalize(cameraPosition-w.xyz);gl_Position=projectionMatrix*viewMatrix*w;}`;
const nFS=`uniform vec3 edgeColor;uniform float opacity,glowIntensity,time;varying vec3 vWP,vN,vV;
void main(){float e=1.0-abs(dot(vN,vV));e=pow(e,1.8);float p=0.85+0.15*sin(time*1.5+vWP.y*2.0);
float g=e*glowIntensity*p;vec3 c=mix(edgeColor*0.05,edgeColor,e*0.9)+edgeColor*g*0.5;gl_FragColor=vec4(c,max(e*opacity,0.06));}`;
function neonMat(color,int){int=int||1.5;return new THREE.ShaderMaterial({vertexShader:nVS,fragmentShader:nFS,
  uniforms:{edgeColor:{value:color.clone()},opacity:{value:0.9},glowIntensity:{value:int},time:{value:0}},
  transparent:true,side:THREE.FrontSide,depthWrite:false});}

// ═══ ROAD SHADER ═══
const rVS=`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`;
const rFS=`uniform vec3 lineColor;uniform float scrollOffset;varying vec2 vUv;
void main(){float cl=smoothstep(0.008,0.003,abs(vUv.x-0.5))*step(0.5,fract(vUv.y*20.0+scrollOffset));
float el=max(smoothstep(0.03,0.02,vUv.x),smoothstep(0.97,0.98,vUv.x));
float g=max(smoothstep(0.005,0.0,abs(fract(vUv.x*12.0)-0.5)-0.48),smoothstep(0.005,0.0,abs(fract(vUv.y*10.0+scrollOffset)-0.5)-0.48))*0.08;
float a=max(max(cl,el*0.7),g);gl_FragColor=vec4(lineColor*(a+0.02),max(a,0.15));}`;

// ═══ GROUND SHADER ═══
const gVS=`varying vec3 vWP;void main(){vec4 w=modelMatrix*vec4(position,1.0);vWP=w.xyz;gl_Position=projectionMatrix*viewMatrix*w;}`;
const gFS=`uniform vec3 gridColor;uniform float scrollOffset,time;varying vec3 vWP;
void main(){vec2 u=vWP.xz*0.08;u.y+=scrollOffset*0.08;
float g=max(smoothstep(0.015,0.0,abs(fract(u.x)-0.5)-0.48),smoothstep(0.015,0.0,abs(fract(u.y)-0.5)-0.48));
float f=exp(-pow(length(vWP.xz)*0.005,2.0));g*=f;
gl_FragColor=vec4(gridColor*g*0.3*(0.8+0.2*sin(time*0.5)),g*0.4*f);}`;

// ═══ SUN ═══
function makeSun(){
  const m=new THREE.ShaderMaterial({
    vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader:`uniform float time;varying vec2 vUv;void main(){vec2 u=vUv;float d=length((u-vec2(0.5,0.35))*vec2(1,1.8));
      float s=smoothstep(0.35,0.28,d)*mix(1.0,step(0.4,fract(u.y*30.0+time*0.3)),step(0.35,1.0-u.y)*0.8);
      vec3 sc=mix(vec3(1,0.6,0),vec3(1,0,0.5),u.y);float h=exp(-pow((u.y-0.3)*3.0,2.0))*0.4;
      gl_FragColor=vec4(sc*s+vec3(0.8,0,0.5)*h,max(s,h*0.6));}`,
    uniforms:{time:{value:0}},transparent:true,depthWrite:false,side:THREE.DoubleSide});
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(120,60),m);mesh.position.set(0,15,350);mesh.renderOrder=-1;return mesh;
}

// ═══ SCENERY ═══
function makeTree(nc){
  const g=new THREE.Group();
  const t=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.2,2.5,6),neonMat(new THREE.Color(0x00ff88),1));t.position.y=1.25;g.add(t);
  [{r:1.8,h:3,y:3.5},{r:1.4,h:2.5,y:5},{r:1,h:2,y:6.2}].forEach(function(s){var c=new THREE.Mesh(new THREE.ConeGeometry(s.r,s.h,6),neonMat(nc,1.2));c.position.y=s.y;g.add(c);});
  return g;
}
function makeBuilding(nc){
  var g=new THREE.Group(),w=3+Math.random()*5,h=6+Math.random()*18,d=3+Math.random()*5;
  var b=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),neonMat(nc,1.3));b.position.y=h/2;g.add(b);
  for(var i=0;i<Math.floor(h/2.5);i++){var wm=new THREE.MeshBasicMaterial({color:nc,transparent:true,opacity:0.3+Math.random()*0.3});
    var wn=new THREE.Mesh(new THREE.PlaneGeometry(w*0.7,0.15),wm);wn.position.set(0,2+i*2.5,d/2+0.01);g.add(wn);
    var wb=wn.clone();wb.position.z=-(d/2+0.01);g.add(wb);}
  return g;
}
function makePalm(nc){
  var g=new THREE.Group();
  var cv=new THREE.CubicBezierCurve3(new THREE.Vector3(0,0,0),new THREE.Vector3(0.3,2.5,0),new THREE.Vector3(-0.2,5,0),new THREE.Vector3(0.1,7,0));
  g.add(new THREE.Mesh(new THREE.TubeGeometry(cv,12,0.2,6,false),neonMat(nc,1)));
  for(var i=0;i<6;i++){var a=(i/6)*Math.PI*2;
    var fc=new THREE.QuadraticBezierCurve3(new THREE.Vector3(0,7,0),new THREE.Vector3(Math.cos(a)*2,7.5,Math.sin(a)*2),new THREE.Vector3(Math.cos(a)*3.5,5.5,Math.sin(a)*3.5));
    g.add(new THREE.Mesh(new THREE.TubeGeometry(fc,8,0.08,4,false),neonMat(new THREE.Color(0x00ff44),1.5)));}
  return g;
}
function makeWater(){
  var m=new THREE.ShaderMaterial({
    vertexShader:`uniform float time;varying vec2 vUv;void main(){vUv=uv;vec3 p=position;p.z+=sin(p.x*0.5+time*0.8)*0.3+sin(p.y*0.3+time*0.5)*0.2;gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}`,
    fragmentShader:`uniform float time;uniform vec3 waterColor;varying vec2 vUv;void main(){
      float g=min(smoothstep(0.02,0.0,abs(fract(vUv.x*20.0+time*0.1)-0.5)-0.48)+smoothstep(0.02,0.0,abs(fract(vUv.y*30.0+time*0.05)-0.5)-0.48),1.0);
      float gl2=g*0.5+0.05;float ef=smoothstep(0.0,0.2,vUv.x)*smoothstep(1.0,0.8,vUv.x);
      gl_FragColor=vec4(waterColor*gl2*ef,gl2*0.6*ef);}`,
    uniforms:{time:{value:0},waterColor:{value:new THREE.Color(0x0066ff)}},transparent:true,depthWrite:false,side:THREE.DoubleSide});
  var mesh=new THREE.Mesh(new THREE.PlaneGeometry(200,60,40,40),m);mesh.rotation.x=-Math.PI/2;mesh.position.set(35,0.05,0);return mesh;
}

// ═══ CHUNKS ═══
var chunks=[],totalChunks=0,biomeIdx=0,biomeTimer=0,activeBiome=biomeOrder[0];

function makeChunk(ci, bk){
  var g=new THREE.Group(),b=BIOMES[bk];g.position.z=ci*C.chunkLength;g.userData={ci:ci,bk:bk};
  // road
  var road=new THREE.Mesh(new THREE.PlaneGeometry(C.roadWidth,C.chunkLength),
    new THREE.ShaderMaterial({vertexShader:rVS,fragmentShader:rFS,uniforms:{time:{value:0},lineColor:{value:b.neonS.clone()},scrollOffset:{value:0}},transparent:true,depthWrite:true}));
  road.rotation.x=-Math.PI/2;road.position.set(0,0.01,C.chunkLength/2);g.add(road);
  // ground
  [-1,1].forEach(function(s){var gm=new THREE.Mesh(new THREE.PlaneGeometry(80,C.chunkLength),
    new THREE.ShaderMaterial({vertexShader:gVS,fragmentShader:gFS,uniforms:{gridColor:{value:b.neonP.clone()},scrollOffset:{value:0},time:{value:0}},transparent:true,depthWrite:false}));
    gm.rotation.x=-Math.PI/2;gm.position.set(s*(C.roadWidth/2+40),0,C.chunkLength/2);g.add(gm);});
  // scenery
  var sc=bk==='city'?5:6;
  for(var i=0;i<sc;i++){var lz=(i/sc)*C.chunkLength+Math.random()*8;
    [-1,1].forEach(function(side){if(Math.random()>0.65)return;var obj;
      if(bk==='countryside'){obj=makeTree(b.neonP);obj.scale.setScalar(0.8+Math.random()*0.6);}
      else if(bk==='city'){obj=makeBuilding(b.neonP);}
      else{obj=makePalm(b.neonP);obj.scale.setScalar(0.7+Math.random()*0.5);}
      var off=bk==='city'?C.roadWidth/2+2+Math.random()*6:C.roadWidth/2+3+Math.random()*20;
      obj.position.set(side*off,0,lz);obj.rotation.y=Math.random()*Math.PI*2;g.add(obj);});}
  if(bk==='beach'){var w=makeWater();w.position.z=C.chunkLength/2;w.position.x=40;g.add(w);}
  scene.add(g);return g;
}
for(var i=0;i<C.visibleChunks;i++){chunks.push(makeChunk(i,activeBiome));totalChunks++;}

// ═══ SUN + STARS ═══
var sun=makeSun();scene.add(sun);
(function(){var geo=new THREE.BufferGeometry(),p=new Float32Array(6000);for(var i=0;i<2000;i++){p[i*3]=(Math.random()-0.5)*600;p[i*3+1]=20+Math.random()*100;p[i*3+2]=(Math.random()-0.5)*600;}
  geo.setAttribute('position',new THREE.BufferAttribute(p,3));scene.add(new THREE.Points(geo,new THREE.PointsMaterial({color:0xffffff,size:0.3,transparent:true,opacity:0.6})));})();

// ═══ CAR ═══
var car, carWheels=[];
function makePlaceholderCar(){
  var g=new THREE.Group();
  var body=new THREE.Mesh(new THREE.BoxGeometry(2,0.8,4.2),neonMat(new THREE.Color(0x00ffff),2));body.position.y=0.7;g.add(body);
  var cabin=new THREE.Mesh(new THREE.BoxGeometry(1.6,0.7,2),neonMat(new THREE.Color(0x00ffff),1.8));cabin.position.set(0,1.3,-0.3);g.add(cabin);
  var wg=new THREE.CylinderGeometry(0.35,0.35,0.25,12),wm=neonMat(new THREE.Color(0xff00ff),2);
  [[-1,0.35,1.3],[1,0.35,1.3],[-1,0.35,-1.3],[1,0.35,-1.3]].forEach(function(p){
    var w=new THREE.Mesh(wg,wm);w.rotation.z=Math.PI/2;w.position.set(p[0],p[1],p[2]);g.add(w);carWheels.push(w);});
  // lights
  [-0.6,0.6].forEach(function(x){var l=new THREE.PointLight(0x00ffff,1.5,15);l.position.set(x,0.7,2.3);g.add(l);});
  [-0.6,0.6].forEach(function(x){var l=new THREE.PointLight(0xff0044,0.8,8);l.position.set(x,0.7,-2.3);g.add(l);});
  return g;
}
car=makePlaceholderCar();car.position.set(0,0,5);scene.add(car);
dbg('Placeholder car loaded');

// Try GLB with official loader
dbg('Attempting GLB load: synth_car.glb', 'warn');
var gltfLoader = new THREE.GLTFLoader();
gltfLoader.load('synth_car.glb',
  function(gltf){
    dbg('GLB loaded successfully!');
    var gc=gltf.scene;

    // Log what we got
    var meshCount=0;
    gc.traverse(function(child){if(child.isMesh)meshCount++;});
    dbg('GLB meshes: '+meshCount);

    // Auto-scale to ~4.2 units
    var box=new THREE.Box3().setFromObject(gc);
    var sz=box.getSize(new THREE.Vector3());
    dbg('GLB size: '+sz.x.toFixed(1)+'x'+sz.y.toFixed(1)+'x'+sz.z.toFixed(1));
    var scaleFactor=4.2/Math.max(sz.x,sz.y,sz.z);
    gc.scale.setScalar(scaleFactor);

    // Rotate 90° anticlockwise to face forward (Blender export fix)
    gc.rotation.y = Math.PI / 2;

    // Re-center
    var sb=new THREE.Box3().setFromObject(gc);
    var ctr=sb.getCenter(new THREE.Vector3());
    gc.position.sub(ctr);
    gc.position.y=-sb.min.y;

    // Swap — create wrapper first so we can add wheels to it (not to rotated gc)
    scene.remove(car);
    car=new THREE.Group();car.add(gc);

    // Add neon wheels to wrapper (not gc) so they aren't affected by Blender rotation fix
    carWheels=[];
    var wg=new THREE.CylinderGeometry(0.32,0.32,0.22,12),wm=neonMat(new THREE.Color(0xff00ff),2);
    [[-0.85,0.32,1.2],[0.85,0.32,1.2],[-0.85,0.32,-1.2],[0.85,0.32,-1.2]].forEach(function(p){
      var w=new THREE.Mesh(wg,wm);w.rotation.z=Math.PI/2;w.position.set(p[0],p[1],p[2]);car.add(w);carWheels.push(w);});
    // lights on wrapper too
    [-0.6,0.6].forEach(function(x){var l=new THREE.PointLight(0x00ffff,1.5,15);l.position.set(x,0.7,2.3);car.add(l);});
    [-0.6,0.6].forEach(function(x){var l=new THREE.PointLight(0xff0044,0.8,8);l.position.set(x,0.7,-2.3);car.add(l);});

    car.position.set(0,0,5);scene.add(car);
    dbg('Car swapped to GLB model!');
  },
  function(progress){
    if(progress.total>0) dbg('GLB loading: '+Math.round(progress.loaded/progress.total*100)+'%','warn');
  },
  function(err){
    dbg('GLB load failed: '+(err.message||err),'err');
    dbg('Using placeholder car','warn');
  }
);

// ═══ LIGHTS ═══
scene.add(new THREE.AmbientLight(0x111122,0.3));
var dl=new THREE.DirectionalLight(0x4444ff,0.4);dl.position.set(-5,10,5);scene.add(dl);

// ═══ INPUT ═══
var keys={},gameStarted=false;
function startGame(){var o=document.getElementById('title-overlay');if(!o.classList.contains('hidden')){o.classList.add('hidden');gameStarted=true;audio.init();audio.switchTo(activeBiome);dbg('Game started!');
  // Retry first track after brief load time
  var retryCount=0;
  var retryInterval=setInterval(function(){
    retryCount++;
    if(audio.retryPlay(activeBiome)){clearInterval(retryInterval);dbg('Music started: '+activeBiome);}
    else if(retryCount>20){clearInterval(retryInterval);dbg('Music load timeout','warn');}
  },250);
}}
window.addEventListener('keydown',function(e){keys[e.key.toLowerCase()]=true;startGame();});
window.addEventListener('keyup',function(e){keys[e.key.toLowerCase()]=false;});
window.addEventListener('pointerdown',startGame);

// ═══ STATE ═══
var speed=0,steer=0,carX=0,distance=0,scrollOff=0,time=0,biomeTransTimer=0;
var camPos=new THREE.Vector3(0,C.camH,-C.camDist),camTgt=new THREE.Vector3(0,1.2,15);

function showBiomeTransition(bk){var el=document.getElementById('biome-transition'),b=BIOMES[bk];
  el.textContent=b.name;el.style.color='#'+b.neonP.getHexString();el.classList.add('show');biomeTransTimer=2.5;}

window.addEventListener('resize',function(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});

// ═══ GAME LOOP ═══
var clock=new THREE.Clock();
function update(){
  var dt=Math.min(clock.getDelta(),0.05);time+=dt;

  if(!gameStarted){
    camera.position.set(Math.sin(time*0.3)*2,C.camH+Math.sin(time*0.5)*0.3,car.position.z-C.camDist);
    camera.lookAt(car.position.x,1.5,car.position.z+10);
    scene.traverse(function(o){if(o.material&&o.material.uniforms){if(o.material.uniforms.time)o.material.uniforms.time.value=time;if(o.material.uniforms.scrollOffset)o.material.uniforms.scrollOffset.value=scrollOff*0.1;}});
    renderer.render(scene,camera);requestAnimationFrame(update);return;
  }

  // Biome timing
  biomeTimer+=dt;
  if(biomeTimer>=C.biomeDur){biomeTimer=0;biomeIdx=(biomeIdx+1)%biomeOrder.length;activeBiome=biomeOrder[biomeIdx];audio.switchTo(activeBiome);showBiomeTransition(activeBiome);}
  if(biomeTransTimer>0){biomeTransTimer-=dt;if(biomeTransTimer<=0)document.getElementById('biome-transition').classList.remove('show');}
  audio.update(dt);

  // Driving
  var thr=keys['arrowup']||keys['w'],brk=keys['arrowdown']||keys['s'],sl=keys['arrowleft']||keys['a'],sr=keys['arrowright']||keys['d'];
  if(thr)speed=Math.min(speed+C.accel*dt,C.maxSpeed);else if(brk)speed=Math.max(speed-C.brake*dt,0);else speed=Math.max(speed-C.friction*dt,0);
  if(sl)steer=Math.max(steer-C.steerSpeed*dt,-C.maxSteer);else if(sr)steer=Math.min(steer+C.steerSpeed*dt,C.maxSteer);
  else{if(Math.abs(steer)<0.05)steer=0;else steer-=Math.sign(steer)*C.steerReturn*dt;}

  var spd=speed/3.6;distance+=spd*dt;scrollOff+=spd*dt;
  carX-=steer*(speed/C.maxSpeed)*12*dt;
  carX=THREE.MathUtils.clamp(carX,-C.roadWidth/2+1.2,C.roadWidth/2-1.2);
  car.position.x=carX;car.rotation.y=-steer*0.3;car.rotation.z=steer*0.05;

  // Wheels
  carWheels.forEach(function(w){w.rotation.x+=spd*dt*3;});

  // Chunks
  chunks.forEach(function(c){c.position.z-=spd*dt;});
  sun.position.z=-50+350;
  chunks.forEach(function(ch,idx){if(ch.position.z<-C.chunkLength*2){
    var mx=-Infinity;chunks.forEach(function(c){if(c.position.z>mx)mx=c.position.z;});
    scene.remove(ch);totalChunks++;var nc=makeChunk(totalChunks,activeBiome);nc.position.z=mx+C.chunkLength;chunks[idx]=nc;}});

  // Camera
  var ip=new THREE.Vector3(carX*0.7,C.camH+(speed/C.maxSpeed)*0.5,car.position.z-C.camDist-(speed/C.maxSpeed)*2);
  var it=new THREE.Vector3(carX*0.5,1.2,car.position.z+15+(speed/C.maxSpeed)*10);
  camPos.lerp(ip,C.camSmoothPos*dt);camTgt.lerp(it,C.camSmoothLook*dt);
  camera.position.copy(camPos);camera.lookAt(camTgt);
  camera.fov=THREE.MathUtils.lerp(camera.fov,65+(speed/C.maxSpeed)*12,dt*2);camera.updateProjectionMatrix();

  // HUD
  document.getElementById('speed-val').textContent=Math.floor(speed);
  document.getElementById('dist-val').textContent=(distance/1000).toFixed(1);
  var be=document.getElementById('biome-name'),bn=BIOMES[activeBiome].name;
  if(be.textContent!==bn){be.textContent=bn;be.style.color='#'+BIOMES[activeBiome].neonP.getHexString();}

  // Fog/sky
  scene.fog.color.lerp(BIOMES[activeBiome].fogColor,dt*0.5);
  scene.background.lerp(BIOMES[activeBiome].skyColor,dt*0.5);

  // Shader uniforms
  scene.traverse(function(o){if(o.material&&o.material.uniforms){if(o.material.uniforms.time)o.material.uniforms.time.value=time;if(o.material.uniforms.scrollOffset)o.material.uniforms.scrollOffset.value=scrollOff*0.1;}});

  renderer.render(scene,camera);requestAnimationFrame(update);
}
update();
dbg('Game loop started');
</script>
</body>
</html>
