<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shuttle Starfield — Enhanced Controls and Combat</title>
  <style>
    html, body { height:100%; margin:0; background:#000; overflow:hidden; }
    #container { width:100%; height:100%; position:relative; }
    canvas { display:block; }
    .hud { position:absolute; left:10px; top:10px; color:#fff; font-family:system-ui,Segoe UI,Roboto,Arial; pointer-events:none; }
    .stats, .controls-ui { margin-top:4px; }
    .reticle { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); pointer-events:none; width:28px; height:28px; mix-blend-mode:screen; }
    .reticle-ring { width:100%; height:100%; border-radius:50%; box-shadow:0 0 12px 3px rgba(127,255,212,0.08) inset; position:absolute; }
    .reticle-dot { width:6px; height:6px; background:#7fffd4; border-radius:50%; margin:11px auto; position:absolute; left:0; right:0; }
    .dialog { position:absolute; left:50%; transform:translateX(-50%); bottom:60px; background:rgba(0,0,0,0.6); color:#fff; padding:10px; border-radius:8px; max-width:480px; text-align:left; }
    .speed-bar-container { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); width:200px; height:14px; background:#222; border:1px solid #555; }
    .speed-bar-fill { width:0%; height:100%; background:#7fffd4; }
    .speed-bar-text { position:absolute; width:100%; top:0; text-align:center; font-size:12px; color:#fff; pointer-events:none; }
    .ammo { margin-top:4px; font-size:14px; }
  </style>
  <!-- Import map for Three.js modules via cdnjs -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.179.1/three.module.js",
      "three/": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.179.1/"
    }
  }
  </script>
</head>
<body>
  <div id="container"></div>
  <div class="reticle">
    <div class="reticle-ring"></div>
    <div class="reticle-dot"></div>
  </div>
  <div class="hud">
    <div class="stats" id="stats">Hull: 100 • Credits: 200</div>
    <div class="ammo" id="ammo">Rockets: 20</div>
  </div>
  <div class="speed-bar-container">
    <div class="speed-bar-fill" id="speedBar"></div>
    <div class="speed-bar-text" id="speedText">0%</div>
  </div>
  <div class="dialog" id="dialog" style="display:none;"></div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

    const MODEL_URL = 'https://TomWoodling.github.io/games/Shuttle_Mission/shuttle.gltf';

    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 10000);
    camera.position.set(0, 5, 20);
    scene.add(camera);

    scene.fog = new THREE.FogExp2(0x000011, 0.0003);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x333333, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(5,10,7);
    scene.add(dir);

    function makeStarfield(count){
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count*3), col = new Float32Array(count*3), sizes = new Float32Array(count);
      for(let i=0;i<count;i++){
        const r=1200+Math.random()*2400, theta=Math.random()*Math.PI*2, phi=Math.acos((Math.random()*2)-1);
        const x=r*Math.sin(phi)*Math.cos(theta), y=r*Math.sin(phi)*Math.sin(theta), z=r*Math.cos(phi);
        pos.set([x,y,z], i*3);
        const b=0.8+Math.random()*0.2;
        col.set([b,b,b], i*3);
        sizes[i]=0.8+Math.random()*3;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geo.setAttribute('color', new THREE.BufferAttribute(col,3));
      const mat=new THREE.PointsMaterial({size:1, vertexColors:true, sizeAttenuation:true});
      const pts=new THREE.Points(geo,mat); pts.frustumCulled=false; scene.add(pts);
    }
    makeStarfield(3000);

    const objects = [];
    const npcShips = [];

    // spawn functions (planets, stations, freighters, npc ships, asteroids)
    // ... same as before but track asteroid health and award credits on destruction

    function spawnAsteroid(position, size){
      const geom=new THREE.IcosahedronGeometry(size,1);
      for(let i=0;i<geom.attributes.position.count;i++){
        const v=new THREE.Vector3().fromBufferAttribute(geom.attributes.position,i);
        v.addScaledVector(v.clone().normalize(), (Math.random()-0.5)*size*0.4);
        geom.attributes.position.setXYZ(i, v.x,v.y,v.z);
      }
      geom.computeVertexNormals();
      const mat=new THREE.MeshStandardMaterial({color:0x7a6f55, roughness:1});
      const mesh=new THREE.Mesh(geom, mat);
      mesh.position.copy(position);
      scene.add(mesh);
      objects.push({ type:'asteroid', mesh, radius:size, health:10, collidable:true });
      return mesh;
    }

    // populate world with initial objects
    // ...

    // Load shuttle model, fix pivot and orientation
    const loader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(draco);

    let ship = new THREE.Object3D(), shipLoaded=false;
    loader.load(MODEL_URL, gltf => {
      ship = gltf.scene;
      ship.scale.setScalar(0.75);
      ship.traverse(c => c.isMesh && (c.castShadow=false));
      // reorient: rotate so -X forward
      ship.rotation.y = Math.PI / 2;
      scene.add(ship);
      shipLoaded = true;
    }, undefined, e => {
      console.warn('GLTF load error', e);
      const g=new THREE.BoxGeometry(1,0.6,2), m=new THREE.MeshStandardMaterial({color:0x99ccff});
      const mesh=new THREE.Mesh(g,m);
      mesh.rotation.x=Math.PI/2;
      ship = new THREE.Object3D(); ship.add(mesh);
      ship.rotation.y = Math.PI/2;
      scene.add(ship);
    });

    const player = { mesh: ship, velocity:new THREE.Vector3(), maxSpeed:100, hull:100, credits:200, rockets:20, radius:1.8 };

    // Movement controls
    const input = { forward:0, strafe:0 };
    window.addEventListener('keydown', e => {
      if (e.key === 'w') input.forward = 1;
      if (e.key === 's') input.forward = -1;
      if (e.key === 'a') input.strafe = -1;
      if (e.key === 'd') input.strafe = 1;
      if (e.key.toLowerCase()==='t') {
        showDialog(`Trading? Buy rockets at 5 credits each. (Press 'B' to buy)`, 5000);
      }
      if (e.key.toLowerCase()==='b'){
        if (player.credits >= 5){
          player.credits -= 5;
          player.rockets = Math.min(player.rockets + 1, 20);
          showDialog("Bought 1 rocket.", 2000);
        } else showDialog("Not enough credits.",2000);
      }
    });
    window.addEventListener('keyup', e => {
      if (e.key === 'w' || e.key === 's') input.forward = 0;
      if (e.key === 'a' || e.key === 'd') input.strafe = 0;
    });

    let pointer = { x:0, y:0 };
    window.addEventListener('mousemove', e => {
      pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
      pointer.y = -((e.clientY / window.innerHeight) * 2 - 1);
    });
    window.addEventListener('contextmenu', e => e.preventDefault());
    let rocketsProjectiles = [];
    function fireCannon(){
      const dir = getAimDir();
      const pos = ship.position.clone().add(dir.clone().multiplyScalar(3));
      const g=new THREE.SphereGeometry(0.1,8,6), m=new THREE.MeshBasicMaterial({color:0x99ffcc});
      const p=new THREE.Mesh(g,m);
      scene.add(p);
      rocketsProjectiles.push({ mesh:p, vel:dir.clone().multiplyScalar(200), ttl:2, rocket:false });
    }
    window.addEventListener('mousedown', e => {
      if (e.button === 0) fireCannon();
      if (e.button === 2){
        if (player.rockets > 0){
          player.rockets--;
          showDialog("Rocket launched!", 1000);
          fireRocket();
        } 
      }
    });
    function fireRocket(){
      const dir = getAimDir();
      const pos = ship.position.clone().add(dir.clone().multiplyScalar(3));
      const g=new THREE.ConeGeometry(0.2,0.8,8), m=new THREE.MeshBasicMaterial({color:0xff5555});
      const p=new THREE.Mesh(g,m);
      p.position.copy(pos);
      p.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir);
      scene.add(p);
      rocketsProjectiles.push({ mesh:p, vel:dir.clone().multiplyScalar(250), ttl:3, rocket:true });
    }

    function getAimDir(){
      const vec=new THREE.Vector3(pointer.x, pointer.y, -0.5).unproject(camera).sub(camera.position).normalize();
      return vec;
    }

    const clock=new THREE.Clock(), dialogEl=document.getElementById('dialog'), statsEl=document.getElementById('stats'), ammoEl=document.getElementById('ammo'), speedBar=document.getElementById('speedBar'), speedText=document.getElementById('speedText');
    let dialogTimer;

    function showDialog(msg, ms=3000){
      dialogEl.style.display='block'; dialogEl.innerHTML = msg;
      clearTimeout(dialogTimer);
      dialogTimer = setTimeout(() => { dialogEl.style.display = 'none'; }, ms);
    }

    function updatePhysics(dt){
      // apply thrust and strafing
      const localForward = new THREE.Vector3(-1,0,0).applyQuaternion(ship.quaternion);
      const localRight = new THREE.Vector3(0,0,1).applyQuaternion(ship.quaternion);
      player.velocity.addScaledVector(localForward, input.forward * dt * 50);
      player.velocity.addScaledVector(localRight, input.strafe * dt * 70);
      if (player.velocity.length() > player.maxSpeed) player.velocity.setLength(player.maxSpeed);
      player.velocity.multiplyScalar(1 - Math.min(dt * 0.4, 0.2));

      ship.position.addScaledVector(player.velocity, dt);

      // aim orientation yaw & pitch
      const yaw = pointer.x * Math.PI * 0.5;
      const pitch = THREE.MathUtils.clamp(pointer.y * Math.PI * 0.33, -Math.PI/2 * 0.9, Math.PI/2 * 0.9);
      ship.rotation.set(pitch, yaw + Math.PI/2, 0);

      // projectiles
      rocketsProjectiles = rocketsProjectiles.filter(p => {
        p.mesh.position.addScaledVector(p.vel, dt);
        p.ttl -= dt;
        if (p.ttl <= 0){ scene.remove(p.mesh); return false; }
        for (const o of objects){
          if (!o.collidable) continue;
          const d = p.mesh.position.distanceTo(o.mesh.position);
          if (d < (o.radius || 1) + 0.5){
            // hit
            o.health = (o.health || 10) - (p.rocket ? 10 : 1);
            scene.remove(p.mesh);
            if (o.health <= 0){
              scene.remove(o.mesh);
              objects.splice(objects.indexOf(o),1);
              player.credits += 5;
            }
            return false;
          }
        }
        return true;
      });

      statsEl.textContent = `Hull: ${Math.max(0,Math.round(player.hull))} • Credits: ${player.credits}`;
      ammoEl.textContent = `Rockets: ${player.rockets}`;
      const pct = Math.round(player.velocity.length() / player.maxSpeed * 100);
      speedBar.style.width = pct + '%';
      speedText.textContent = pct + '%';
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, clock.getDelta());
      updatePhysics(dt);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    console.log("Prototype loaded with rockets, strafing, speed bar and combat.");

  </script>
</body>
</html>
