<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shuttle Starfield — Full & Polished</title>
  <style>
    html, body { height:100%; margin:0; background:#000; overflow:hidden; }
    #container { width:100%; height:100%; position:relative; }
    canvas { display:block; }
    .hud { position:absolute; left:10px; top:10px; color:#fff; font-family:system-ui; pointer-events:none; }
    .stats, .ammo { margin-top:4px; }
    .reticle { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:28px; height:28px; pointer-events:none; mix-blend-mode:screen; }
    .reticle-ring { width:100%; height:100%; border-radius:50%; box-shadow:0 0 12px 3px rgba(127,255,212,0.08) inset; position:absolute; }
    .reticle-dot { width:6px; height:6px; background:#7fffd4; border-radius:50%; margin:11px auto; position:absolute; left:0; right:0; }
    .dialog { position:absolute; left:50%; transform:translateX(-50%); bottom:60px; background:rgba(0,0,0,0.6); color:#fff; padding:10px; border-radius:8px; max-width:480px; text-align:left; }
    .speed-bar-container { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); width:200px; height:14px; background:#222; border:1px solid #555; }
    .speed-bar-fill { width:0%; height:100%; background:#7fffd4; }
    .speed-bar-text { position:absolute; width:100%; top:0; text-align:center; font-size:12px; color:#fff; pointer-events:none; }
  </style>

  <!--  Import map polyfill for resolving bare specifiers like 'three' -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

  <!-- import map mapping 'three' and examples path to CDN modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.179.1/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.179.1/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="container"></div>
  <div class="reticle"><div class="reticle-ring"></div><div class="reticle-dot"></div></div>
  <div class="hud">
    <div class="stats" id="stats">Hull: 100 • Credits: 200</div>
    <div class="ammo" id="ammo">Rockets: 20</div>
  </div>
  <div class="speed-bar-container"><div class="speed-bar-fill" id="speedBar"></div><div class="speed-bar-text" id="speedText">0%</div></div>
  <div class="dialog" id="dialog" style="display:none;"></div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

    const MODEL_URL = 'https://TomWoodling.github.io/games/Shuttle_Mission/shuttle.gltf';
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 10000);
    scene.add(camera);
    scene.fog = new THREE.FogExp2(0x000011, 0.0003);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x333333, 0.8));
    const light = new THREE.DirectionalLight(0xffffff, 0.6);
    light.position.set(5,10,7);
    scene.add(light);

    function makeStarfield(n) {
      const geo = new THREE.BufferGeometry(), p=new Float32Array(n*3), c=new Float32Array(n*3);
      for (let i=0;i<n;i++){
        const r=1200+Math.random()*2400, t=Math.random()*Math.PI*2, f=Math.acos(Math.random()*2-1);
        p.set([r*Math.sin(f)*Math.cos(t), r*Math.sin(f)*Math.sin(t), r*Math.cos(f)], i*3);
        const b=0.8+Math.random()*0.2; c.set([b,b,b], i*3);
      }
      geo.setAttribute('position', new THREE.BufferAttribute(p,3));
      geo.setAttribute('color', new THREE.BufferAttribute(c,3));
      const pm = new THREE.PointsMaterial({size:1,vertexColors:true,sizeAttenuation:true});
      const pts = new THREE.Points(geo,pm); pts.frustumCulled = false; scene.add(pts);
    }
    makeStarfield(3000);

    const objects = [], npcShips = [];
    function spawnPlanetoid(pos,size){ const geo=new THREE.SphereGeometry(size,32,24); const mat=new THREE.MeshStandardMaterial({color:new THREE.Color().setHSL(Math.random(),0.5,0.2),roughness:1}); const m=new THREE.Mesh(geo,mat); m.position.copy(pos); scene.add(m); objects.push({type:'planet',mesh:m,radius:size,collidable:false}); }
    function spawnStation(pos,size){ const geo=new THREE.TorusGeometry(size*1.6,size*0.3,16,100); const mat=new THREE.MeshStandardMaterial({color:0x8888aa,metalness:0.5,roughness:0.4}); const m=new THREE.Mesh(geo,mat); m.position.copy(pos); m.rotation.x=Math.PI/2; scene.add(m); objects.push({type:'station',mesh:m,radius:size*1.8,collidable:true}); }
    function spawnFreighter(pos,size){ const geo=new THREE.BoxGeometry(size*2,size*0.6,size*0.8); const mat=new THREE.MeshStandardMaterial({color:0x555577,metalness:0.6,roughness:0.5}); const m=new THREE.Mesh(geo,mat); m.position.copy(pos); scene.add(m); objects.push({type:'freighter',mesh:m,radius:Math.max(size*1.4,1),collidable:true}); }
    function spawnNPCShip(pos,dir){ const geo=new THREE.ConeGeometry(0.6,2,12); const mat=new THREE.MeshStandardMaterial({color:0xff8844}); const m=new THREE.Mesh(geo,mat); m.position.copy(pos); m.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),dir.clone().normalize()); scene.add(m); const d={type:'npc',mesh:m,radius:1.2,velocity:dir.clone().multiplyScalar(0.5),collidable:true}; npcShips.push(d); objects.push(d); }
    function spawnAsteroid(pos,size){ const geo=new THREE.IcosahedronGeometry(size,1); for(let i=0;i<geo.attributes.position.count;i++){ const v=new THREE.Vector3().fromBufferAttribute(geo.attributes.position,i); v.addScaledVector(v.clone().normalize(), (Math.random()-0.5)*size*0.4); geo.attributes.position.setXYZ(i,v.x,v.y,v.z); } geo.computeVertexNormals(); const mat=new THREE.MeshStandardMaterial({color:0x7a6f55,roughness:1}); const m=new THREE.Mesh(geo,mat); m.position.copy(pos); scene.add(m); objects.push({type:'asteroid',mesh:m,radius:size,health:10,collidable:true}); }

    for (let i=0;i<6;i++) spawnPlanetoid(new THREE.Vector3((Math.random()-0.5)*400,(Math.random()-0.5)*200,(Math.random()-0.5)*400),8+Math.random()*40);
    for (let i=0;i<3;i++) spawnStation(new THREE.Vector3((Math.random()-0.5)*800,(Math.random()-0.5)*200,(Math.random()-0.5)*800),20+Math.random()*30);
    for (let i=0;i<4;i++) spawnFreighter(new THREE.Vector3((Math.random()-0.5)*1000,(Math.random()-0.5)*200,(Math.random()-0.5)*1000),8+Math.random()*15);
    for (let i=0;i<8;i++) spawnNPCShip(new THREE.Vector3((Math.random()-0.5)*800,(Math.random()-0.5)*200,(Math.random()-0.5)*800),new THREE.Vector3(Math.random()-0.5,(Math.random()-0.5)*0.5,Math.random()-0.5));

    const loader = new GLTFLoader(); const draco = new DRACOLoader(); draco.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/'); loader.setDRACOLoader(draco);
    let ship=new THREE.Object3D(), shipLoaded=false;
    loader.load(MODEL_URL, gltf=>{ ship=gltf.scene; ship.scale.setScalar(0.75); ship.rotation.y=Math.PI/2; scene.add(ship); shipLoaded=true; }, undefined, err=>{ console.warn('Model load error', err); const g=new THREE.BoxGeometry(1,0.6,2), m2=new THREE.MeshStandardMaterial({color:0x99ccff}), mm=new THREE.Mesh(g,m2); mm.rotation.x=Math.PI/2; ship=new THREE.Object3D(); ship.add(mm); ship.rotation.y=Math.PI/2; scene.add(ship); });

    const player={mesh:ship,velocity:new THREE.Vector3(),maxSpeed:100,hull:100,credits:200,rockets:20,radius:1.8};
    const input={forward:0,strafe:0}; window.addEventListener('keydown', e=>{ if(e.key==='w') input.forward=1; if(e.key==='s') input.forward=-1; if(e.key==='a') input.strafe=-1; if(e.key==='d') input.strafe=1; if(e.key.toLowerCase()==='t') showDialog("Buy rockets at 5 credits each. Press 'B' to buy.",4000); if(e.key.toLowerCase()==='b'){ if(player.credits>=5&&player.rockets<20){player.credits-=5;player.rockets++;showDialog("Bought 1 rocket.",2000);} else if(player.rockets>=20) showDialog("Rocket inventory full.",2000); else showDialog("Not enough credits.",2000); } }); window.addEventListener('keyup', e=>{ if(['w','s'].includes(e.key)) input.forward=0; if(['a','d'].includes(e.key)) input.strafe=0; });

    const pointer={x:0,y:0}; window.addEventListener('mousemove', e=>{ pointer.x=(e.clientX/window.innerWidth)*2-1; pointer.y=-((e.clientY/window.innerHeight)*2-1); }); window.addEventListener('contextmenu', e=>e.preventDefault());
    const projectiles=[]; function fireCannon(){ const dir=getAimDirection(), pos=ship.position.clone().add(dir.clone().multiplyScalar(3)), g=new THREE.SphereGeometry(0.1,8,6), m3=new THREE.MeshBasicMaterial({color:0x99ffcc}), p=new THREE.Mesh(g,m3); p.position.copy(pos); scene.add(p); projectiles.push({mesh:p,vel:dir.clone().multiplyScalar(200),ttl:2,isRocket:false}); }
    function fireRocket(){ player.rockets--; showDialog("Rocket fired!",1000); const dir=getAimDirection(), pos=ship.position.clone().add(dir.clone().multiplyScalar(3)), g=new THREE.ConeGeometry(0.2,0.8,8), m4=new THREE.MeshBasicMaterial({color:0xff5555}), p=new THREE.Mesh(g,m4); p.position.copy(pos); p.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),dir); scene.add(p); projectiles.push({mesh:p,vel:dir.clone().multiplyScalar(250),ttl:3,isRocket:true}); }
    window.addEventListener('mousedown', e=>{ if(e.button===0) fireCannon(); if(e.button===2&&player.rockets>0) fireRocket(); });

    function getAimDirection(){ const v=new THREE.Vector3(pointer.x,pointer.y,-0.5).unproject(camera).sub(camera.position).normalize(); return v; }

    const clock=new THREE.Clock(), statsEl=document.getElementById('stats'), ammoEl=document.getElementById('ammo'), speedBarEl=document.getElementById('speedBar'), speedTextEl=document.getElementById('speedText'), dialogEl=document.getElementById('dialog');
    let dialogTimer;
    function showDialog(msg,time=3000){ dialogEl.style.display='block'; dialogEl.textContent=msg; clearTimeout(dialogTimer); dialogTimer=setTimeout(()=>dialogEl.style.display='none',time); }

    function update(dt){
      // Ship-relative movement
      const forward = new THREE.Vector3(-1,0,0).applyQuaternion(ship.quaternion);
      const right = new THREE.Vector3(0,0,1).applyQuaternion(ship.quaternion);
      player.velocity.addScaledVector(forward, input.forward*dt*50);
      player.velocity.addScaledVector(right, input.strafe*dt*70);
      if (player.velocity.length()>player.maxSpeed) player.velocity.setLength(player.maxSpeed);
      player.velocity.multiplyScalar(1 - Math.min(dt*0.4,0.2));
      ship.position.addScaledVector(player.velocity, dt);

      // Aiming (mouse) orientation
      const yaw = pointer.x * Math.PI*0.5;
      const pitch = THREE.MathUtils.clamp(pointer.y * Math.PI*0.33, -Math.PI/2 * 0.9, Math.PI/2 * 0.9 );
      ship.rotation.set(pitch, yaw + Math.PI/2, 0);

      // Projectiles & collisions...
      for (let i=projectiles.length - 1; i>=0; i--){
        const p = projectiles[i];
        p.mesh.position.addScaledVector(p.vel, dt);
        p.ttl -= dt;
        if (p.ttl <= 0){
          scene.remove(p.mesh);
          projectiles.splice(i,1);
          continue;
        }
        for (const o of objects){
          if (o.collidable && p.mesh.position.distanceTo(o.mesh.position) < (o.radius + 0.5)){
            o.health = (o.health || 10) - (p.isRocket?10:1);
            scene.remove(p.mesh); projectiles.splice(i,1);
            if (o.health <= 0){
              scene.remove(o.mesh); objects.splice(objects.indexOf(o),1); player.credits += 5;
            }
            break;
          }
        }
      }

      // HUD updates
      statsEl.textContent = `Hull: ${Math.max(0,Math.round(player.hull))} • Credits: ${player.credits}`;
      ammoEl.textContent = `Rockets: ${player.rockets}`;
      const pct = Math.round(player.velocity.length() / player.maxSpeed * 100);
      speedBarEl.style.width = pct + '%';
      speedTextEl.textContent = pct + '%';
    }

    function updateCamera(dt){
      const height = 5, distance = 20, damping = 2;
      const desired = new THREE.Vector3(0, height, distance).applyQuaternion(ship.quaternion).add(ship.position);
      camera.position.lerp(desired, damping * dt);
      camera.lookAt(ship.position);
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, clock.getDelta());
      update(dt);
      updateCamera(dt);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    console.log('Fully polished version loaded—drop-in ready!');
  </script>
</body>
</html>
