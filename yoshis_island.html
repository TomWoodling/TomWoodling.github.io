<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Mario Bros - Platformer Deluxe</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            background: #222; /* Darker background for contrast */
        }
        #gameContainer {
            position: relative;
            border: 3px solid #000;
            border-radius: 8px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            background: linear-gradient(to bottom, #5C94FC, #B8E8FF);
        }
        #gameCanvas { display: block; }
        #hud {
            position: absolute; top: 10px; left: 10px; color: white;
            font-size: 16px; font-weight: bold; text-shadow: 2px 2px 0px #000; z-index: 10;
        }
        #gameOver, #levelComplete, #gameComplete {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85); color: white; padding: 30px; border-radius: 10px;
            text-align: center; display: none; z-index: 20; box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        #gameOver h2, #levelComplete h2, #gameComplete h2 { margin-bottom: 15px; font-size: 28px; }
        #gameOver p, #levelComplete p, #gameComplete p { margin-bottom: 10px; font-size: 18px; }
        #gameOver button, #levelComplete button, #gameComplete button {
            background: #4CAF50; color: white; border: none; padding: 12px 25px;
            font-size: 18px; border-radius: 5px; cursor: pointer; margin-top: 15px;
            transition: background-color 0.2s;
        }
        #gameOver button:hover, #levelComplete button:hover, #gameComplete button:hover { background: #45a049; }
        #instructions {
            position: absolute; bottom: 10px; left: 10px; color: white;
            font-size: 12px; text-shadow: 1px 1px 0px #000;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="hud">
            <div>Level: <span id="levelDisplay">1</span></div>
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Coins: <span id="coins">0</span></div>
        </div>
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="restartGame(true)">Play Again (From Level 1)</button>
        </div>
        <div id="levelComplete">
            <h2>Level <span id="completedLevelNum">1</span> Complete!</h2>
            <p>Score: <span id="finalScoreLevelComplete">0</span></p>
            <p>Coins: <span id="finalCoinsLevelComplete">0</span></p>
            <button onclick="nextLevel()">Next Level</button>
        </div>
        <div id="gameComplete">
            <h2>Congratulations!</h2>
            <p>You've completed all levels!</p>
            <p>Final Score: <span id="finalScoreGameComplete">0</span></p>
            <button onclick="restartGame(true)">Play Again (From Level 1)</button>
        </div>
        <div id="instructions">
            Arrow Keys / WASD: Move • Space/W: Jump • R: Restart Level • X: Yoshi Tongue/Spit
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = {
            currentLevel: 0, score: 0, lives: 3, coins: 0,
            gameOver: false, levelCompleteFlag: false, gameCompleteFlag: false,
            camera: { x: 0, y: 0 }
        };
        
        const keys = {};
        
        const player = {
            x: 100, y: 200, width: 24, height: 32,
            vx: 0, vy: 0, grounded: false, speed: 4, jumpPower: 12,
            direction: 1, animFrame: 0, animTimer: 0,
            invulnerable: false, invulnerabilityTimer: 0,
            onYoshi: false, yoshiHeldEnemy: null,
        };

        const yoshiTongue = {
            active: false, x: 0, y: 0, currentLength: 0, maxLength: 80, 
            width: 6, height: 6, speed: 20, direction: 1, retracting: false
        };

        let spatEnemies = []; // Projectiles spat by Yoshi

        // --- LEVEL DATA ---
        const levelData = [
            // LEVEL 1
            {
                platforms: [
                    { x: 0, y: 350, width: 200, height: 50, type: 'ground' }, { x: 250, y: 350, width: 150, height: 50, type: 'ground' },
                    { x: 450, y: 350, width: 200, height: 50, type: 'ground' }, { x: 700, y: 350, width: 300, height: 50, type: 'ground' },
                    { x: 1100, y: 350, width: 200, height: 50, type: 'ground' }, { x: 1400, y: 350, width: 300, height: 50, type: 'ground' },
                    { x: 300, y: 280, width: 80, height: 16, type: 'platform' }, { x: 500, y: 220, width: 80, height: 16, type: 'platform' },
                    { x: 650, y: 180, width: 100, height: 16, type: 'platform' }, { x: 850, y: 250, width: 80, height: 16, type: 'platform' },
                    { x: 1000, y: 200, width: 80, height: 16, type: 'platform' }, { x: 1200, y: 150, width: 100, height: 16, type: 'platform' },
                    { x: 400, y: 120, width: 120, height: 12, type: 'skybar' }, { x: 750, y: 100, width: 100, height: 12, type: 'skybar' },
                    { x: 1050, y: 80, width: 150, height: 12, type: 'skybar' }, { x: 1350, y: 120, width: 100, height: 12, type: 'skybar' },
                    { x: 1750, y: 350, width: 250, height: 50, type: 'ground' }, { x: 1800, y: 280, width: 60, height: 16, type: 'platform' },
                    { x: 1950, y: 220, width: 80, height: 16, type: 'platform' }, { x: 2100, y: 180, width: 100, height: 16, type: 'platform' },
                    { x: 2050, y: 350, width: 300, height: 50, type: 'ground' }, { x: 2400, y: 350, width: 100, height: 50, type: 'ground' },
                    { x: 2600, y: 350, width: 400, height: 50, type: 'ground' }, { x: 2650, y: 250, width: 80, height: 16, type: 'platform' },
                    { x: 2800, y: 200, width: 80, height: 16, type: 'platform' }, { x: 2950, y: 150, width: 80, height: 16, type: 'platform' },
                    { x: 3050, y: 350, width: 200, height: 50, type: 'ground' }, { x: 3300, y: 350, width: 150, height: 50, type: 'ground' },
                    { x: 3500, y: 350, width: 300, height: 50, type: 'ground' }, { x: 3200, y: 280, width: 40, height: 16, type: 'platform' },
                    { x: 3300, y: 240, width: 40, height: 16, type: 'platform' }, { x: 3400, y: 200, width: 40, height: 16, type: 'platform' },
                    { x: 3500, y: 160, width: 40, height: 16, type: 'platform' }, { x: 1900, y: 120, width: 120, height: 12, type: 'skybar' },
                    { x: 2250, y: 100, width: 100, height: 12, type: 'skybar' }, { x: 2700, y: 80, width: 150, height: 12, type: 'skybar' },
                    { x: 3150, y: 120, width: 100, height: 12, type: 'skybar' }, { x: 3600, y: 100, width: 100, height: 12, type: 'skybar' },
                    { x: 3850, y: 350, width: 500, height: 50, type: 'ground' }, { x: 4400, y: 350, width: 200, height: 50, type: 'ground' },
                    { x: 4650, y: 300, width: 80, height: 16, type: 'platform' }, { x: 4750, y: 350, width: 300, height: 50, type: 'ground' },
                ],
                coins: [
                    { x: 320, y: 250 }, { x: 520, y: 190 }, { x: 680, y: 150 }, { x: 870, y: 220 }, { x: 1020, y: 170 }, { x: 1220, y: 120 },
                    { x: 1820, y: 250 }, { x: 1970, y: 190 }, { x: 2130, y: 150 }, { x: 2670, y: 220 }, { x: 2820, y: 170 }, { x: 2970, y: 120 },
                    { x: 3210, y: 250 }, { x: 3310, y: 210 }, { x: 3410, y: 170 }, { x: 3510, y: 130 }, { x: 4000, y: 300 }, { x: 4200, y: 300 },
                    { x: 4700, y: 270 },
                ],
                enemies: [
                    { originalX: 280, y: 318, originalVX: -1, type: 'turtle' }, { originalX: 480, y: 318, originalVX: 1, type: 'turtle' },
                    { originalX: 720, y: 318, originalVX: -1, type: 'goomba' }, { originalX: 1150, y: 326, originalVX: 1, type: 'goomba' }, // Goombas are shorter
                    { originalX: 1450, y: 318, originalVX: -1, type: 'turtle' }, { originalX: 1850, y: 318, originalVX: -1, type: 'turtle' },
                    { originalX: 2100, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 2120, y: 180 - 16, originalVX: -1, type: 'goomba' }, // Goomba on platform
                    { originalX: 2700, y: 318, originalVX: -1, type: 'turtle' }, { originalX: 3100, y: 326, originalVX: 1, type: 'goomba' },
                    { originalX: 3600, y: 318, originalVX: -1, type: 'turtle' }, { originalX: 4100, y: 326, originalVX: 1, type: 'goomba' },
                    { originalX: 4500, y: 318, originalVX: -1, type: 'turtle' }, { originalX: 4800, y: 326, originalVX: 1, type: 'goomba' },
                ],
                yoshiSpawns: [{ x: 600, y: 300, width: 32, height: 32}], // Yoshi Egg
                goal: { x: 4900, y: 250, width: 20, height: 100 }
            },
            // LEVEL 2 - Twin Track
            {
                platforms: [
                    // Lower Track (long ground sections)
                    { x: 0, y: 350, width: 800, height: 50, type: 'ground' },
                    { x: 900, y: 350, width: 1200, height: 50, type: 'ground' }, // Gap 800-900
                    { x: 2200, y: 350, width: 1000, height: 50, type: 'ground' }, // Gap 2100-2200
                    { x: 3300, y: 350, width: 1500, height: 50, type: 'ground' }, // Gap 3200-3300
                    { x: 4900, y: 350, width: 800, height: 50, type: 'ground' },  // Gap 4800-4900

                    // Upper Track (long platforms)
                    { x: 100, y: 180, width: 600, height: 20, type: 'platform' },
                    { x: 800, y: 180, width: 700, height: 20, type: 'platform' }, // Gap 700-800
                    { x: 1600, y: 180, width: 800, height: 20, type: 'platform' },// Gap 1500-1600
                    { x: 2500, y: 180, width: 900, height: 20, type: 'platform' },// Gap 2400-2500
                    { x: 3500, y: 180, width: 1000, height: 20, type: 'platform' },// Gap 3400-3500
                    { x: 4600, y: 180, width: 700, height: 20, type: 'platform' }, // Gap 4500-4600
                    
                    // Connecting platforms / skybars
                    { x: 750, y: 280, width: 50, height: 16, type: 'platform' }, // Step up/down
                    { x: 1550, y: 280, width: 50, height: 16, type: 'platform' },
                    { x: 2450, y: 280, width: 50, height: 16, type: 'platform' },
                    { x: 3450, y: 280, width: 50, height: 16, type: 'platform' },
                    { x: 4550, y: 280, width: 50, height: 16, type: 'platform' },

                    { x: 400, y: 100, width: 150, height: 12, type: 'skybar' },
                    { x: 1200, y: 80, width: 200, height: 12, type: 'skybar' },
                    { x: 2000, y: 100, width: 150, height: 12, type: 'skybar' },
                    { x: 2900, y: 80, width: 250, height: 12, type: 'skybar' },
                    { x: 4000, y: 100, width: 200, height: 12, type: 'skybar' },
                    { x: 5000, y: 80, width: 150, height: 12, type: 'skybar' },
                ],
                coins: [
                    // Lower track coins
                    { x: 150, y: 320 }, { x: 450, y: 320 }, { x: 750, y: 320 },
                    { x: 1000, y: 320 }, { x: 1300, y: 320 }, { x: 1600, y: 320 }, { x: 1900, y: 320 },
                    { x: 2300, y: 320 }, { x: 2600, y: 320 }, { x: 2900, y: 320 },
                    { x: 3400, y: 320 }, { x: 3700, y: 320 }, { x: 4000, y: 320 }, { x: 4300, y: 320 },
                    { x: 5000, y: 320 }, { x: 5300, y: 320 },
                    // Upper track coins
                    { x: 200, y: 150 }, { x: 500, y: 150 }, 
                    { x: 900, y: 150 }, { x: 1200, y: 150 }, { x: 1450, y: 150 },
                    { x: 1700, y: 150 }, { x: 2000, y: 150 }, { x: 2300, y: 150 },
                    { x: 2600, y: 150 }, { x: 2900, y: 150 }, { x: 3200, y: 150 },
                    { x: 3600, y: 150 }, { x: 3900, y: 150 }, { x: 4200, y: 150 },
                    { x: 4700, y: 150 }, { x: 5000, y: 150 }, { x: 5200, y: 150 },
                ],
                enemies: [
                    // Lower track enemies
                    { originalX: 300, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 600, y: 318, originalVX: -1, type: 'turtle' },
                    { originalX: 1100, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 1400, y: 318, originalVX: -1, type: 'turtle' },
                    { originalX: 1800, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 2000, y: 318, originalVX: -1, type: 'turtle' },
                    { originalX: 2500, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 2800, y: 318, originalVX: -1, type: 'turtle' },
                    { originalX: 3500, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 3800, y: 318, originalVX: -1, type: 'turtle' },
                    { originalX: 4200, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 4500, y: 318, originalVX: -1, type: 'turtle' },
                    { originalX: 5100, y: 326, originalVX: 1, type: 'goomba' }, { originalX: 5400, y: 318, originalVX: -1, type: 'turtle' },
                    // Upper track enemies
                    { originalX: 400, y: 180 - 16, originalVX: 1, type: 'goomba' }, { originalX: 1000, y: 180 - 24, originalVX: -1, type: 'turtle' },
                    { originalX: 1800, y: 180 - 16, originalVX: 1, type: 'goomba' }, { originalX: 2700, y: 180 - 24, originalVX: -1, type: 'turtle' },
                    { originalX: 3700, y: 180 - 16, originalVX: 1, type: 'goomba' }, { originalX: 4800, y: 180 - 24, originalVX: -1, type: 'turtle' },
                ],
                yoshiSpawns: [{ x: 150, y: 130, width: 32, height: 32 }], // Yoshi Egg on upper platform
                goal: { x: 5600, y: 250, width: 20, height: 100 }
            }
        ];

        let currentPlatforms = [];
        let currentCoins = [];
        let currentEnemies = [];
        let currentYoshiSpawns = [];
        let currentGoal = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'KeyR') restartGame(false); // Restart current level
            if (e.code === 'KeyX' && player.onYoshi) {
                if (player.yoshiHeldEnemy) {
                    // Spit enemy
                    spatEnemies.push({
                        x: player.x + (player.direction > 0 ? player.width : -24), // 24 is enemy width
                        y: player.y + player.height / 2 - 12, // 12 is half enemy height
                        vx: 12 * player.direction, // Faster than normal enemy
                        vy: 0,
                        width: player.yoshiHeldEnemy.width, // Use held enemy's dimensions
                        height: player.yoshiHeldEnemy.height,
                        type: player.yoshiHeldEnemy.type,
                        alive: true,
                        isSpat: true
                    });
                    player.yoshiHeldEnemy = null;
                } else if (!yoshiTongue.active) {
                    // Shoot tongue
                    yoshiTongue.active = true;
                    yoshiTongue.retracting = false;
                    yoshiTongue.currentLength = 0;
                    yoshiTongue.direction = player.direction;
                    // Position tongue from Yoshi's mouth (adjust player.height part for yoshi)
                    let yoshiHeadY = player.y + (player.height - 10); // Approx Yoshi head height
                    yoshiTongue.x = player.x + (player.direction > 0 ? player.width + 2 : -yoshiTongue.width - 2);
                    yoshiTongue.y = yoshiHeadY - yoshiTongue.height / 2;
                }
            }
        });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });
        
        function checkCollision(rect1, rect2) {
            if (!rect1 || !rect2) return false;
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }
        
        function handleInput() {
            if (gameState.gameOver || gameState.levelCompleteFlag || gameState.gameCompleteFlag) return;
            
            if (keys['ArrowLeft'] || keys['KeyA']) { player.vx = -player.speed; player.direction = -1; }
            else if (keys['ArrowRight'] || keys['KeyD']) { player.vx = player.speed; player.direction = 1; }
            else { player.vx *= 0.8; }
            
            if ((keys['Space'] || keys['KeyW'] || keys['ArrowUp']) && player.grounded) {
                player.vy = -player.jumpPower;
                if (player.onYoshi) player.vy -= 2; // Yoshi Jumps Higher / Flutter
                player.grounded = false;
            }
        }

        function updateYoshiTongue() {
            if (!yoshiTongue.active) return;

            if (!yoshiTongue.retracting) {
                yoshiTongue.currentLength += yoshiTongue.speed;
                if (yoshiTongue.currentLength >= yoshiTongue.maxLength) {
                    yoshiTongue.currentLength = yoshiTongue.maxLength;
                    yoshiTongue.retracting = true;
                }

                // Tongue collision rect
                let tongueRect = {
                    x: yoshiTongue.direction > 0 ? yoshiTongue.x : yoshiTongue.x - yoshiTongue.currentLength + yoshiTongue.width,
                    y: yoshiTongue.y,
                    width: yoshiTongue.currentLength,
                    height: yoshiTongue.height
                };
                if (yoshiTongue.direction < 0) { // Adjust x for left-facing tongue
                    tongueRect.x = yoshiTongue.x - yoshiTongue.currentLength;
                }


                currentEnemies.forEach(enemy => {
                    if (enemy.alive && checkCollision(tongueRect, enemy)) {
                        if (!player.yoshiHeldEnemy) { // Can only eat one at a time
                            enemy.alive = false; // Enemy is "eaten"
                            player.yoshiHeldEnemy = { type: enemy.type, originalData: {...enemy}, width: enemy.width, height: enemy.height }; // Store type and original data
                            yoshiTongue.retracting = true; // Retract immediately
                            gameState.score += 50; // Score for eating
                        }
                    }
                });

            } else { // Retracting
                yoshiTongue.currentLength -= yoshiTongue.speed * 1.5; // Retract faster
                if (yoshiTongue.currentLength <= 0) {
                    yoshiTongue.active = false;
                    yoshiTongue.currentLength = 0;
                }
            }
        }

        function updateSpatEnemies() {
            for (let i = spatEnemies.length - 1; i >= 0; i--) {
                const spat = spatEnemies[i];
                if (!spat.alive) {
                    spatEnemies.splice(i, 1);
                    continue;
                }
                spat.x += spat.vx;
                // Basic gravity for spat enemies, or just fly straight
                // spat.vy += 0.5; 
                // spat.y += spat.vy;

                // Collision with other enemies
                currentEnemies.forEach(enemy => {
                    if (enemy.alive && checkCollision(spat, enemy)) {
                        enemy.alive = false; // Defeat other enemy
                        spat.alive = false; // Spat enemy also disappears on hit
                        gameState.score += 150; // Bonus for multi-kill
                    }
                });
                
                // Collision with platforms (spat enemy breaks)
                currentPlatforms.forEach(platform => {
                    if(checkCollision(spat, platform)){
                        spat.alive = false;
                    }
                });

                // Remove if off-screen
                if (spat.x < gameState.camera.x - 50 || spat.x > gameState.camera.x + canvas.width + 50) {
                    spat.alive = false;
                }
            }
        }
        
        function updatePlayer() {
            if (gameState.gameOver || gameState.levelCompleteFlag || gameState.gameCompleteFlag) return;
            
            player.vy += 0.5; // Gravity
            player.x += player.vx;
            player.y += player.vy;
            
            player.grounded = false;
            
            currentPlatforms.forEach(platform => {
                if (checkCollision(player, platform)) {
                    if (player.vy > 0 && player.y + player.height - player.vy <= platform.y + 1) {
                        player.y = platform.y - player.height;
                        player.vy = 0;
                        player.grounded = true;
                    } else if (player.vy < 0 && player.y - player.vy >= platform.y + platform.height -1) {
                        player.y = platform.y + platform.height;
                        player.vy = 0;
                    } else if (player.vx > 0 && player.x + player.width - player.vx <= platform.x +1) {
                        player.x = platform.x - player.width; player.vx = 0;
                    } else if (player.vx < 0 && player.x - player.vx >= platform.x + platform.width -1) {
                        player.x = platform.x + platform.width; player.vx = 0;
                    }
                }
            });
            
            currentCoins.forEach(coin => {
                if (!coin.collected && checkCollision(player, coin)) {
                    coin.collected = true; gameState.coins++; gameState.score += 100;
                }
            });

            currentYoshiSpawns.forEach(yoshi => {
                if (!yoshi.collected && checkCollision(player, yoshi)) {
                    yoshi.collected = true;
                    player.onYoshi = true;
                    player.height = 48; // Yoshi is taller
                    player.y -= (48-32); // Adjust y pos
                }
            });
            
            if (!player.invulnerable) {
                currentEnemies.forEach(enemy => {
                    if (enemy.alive && checkCollision(player, enemy)) {
                        if (player.vy > 0 && player.y + player.height - player.vy <= enemy.y + 5) {
                            enemy.alive = false; player.vy = -8; gameState.score += 200;
                            if(player.onYoshi) player.vy -=2; // Yoshi bounce
                        } else {
                            takeDamage();
                        }
                    }
                });
            }
            
            if (player.invulnerable) {
                player.invulnerabilityTimer--;
                if (player.invulnerabilityTimer <= 0) player.invulnerable = false;
            }
            
            if (Math.abs(player.vx) > 0.1) {
                player.animTimer++;
                if (player.animTimer > (player.onYoshi ? 6 : 8)) { // Yoshi animation faster
                    player.animFrame = (player.animFrame + 1) % (player.onYoshi ? 2 : 4); // Yoshi 2 frames, Mario 4
                    player.animTimer = 0;
                }
            }
            
            if (player.y > canvas.height + 100) {
                if (!gameState.gameOver && !gameState.levelCompleteFlag) {
                    takeDamage();
                    if (!gameState.gameOver) respawnPlayer();
                }
            }

            if (!currentGoal.reached && checkCollision(player, currentGoal)) {
                currentGoal.reached = true;
                completeLevel();
            }
            
            gameState.camera.x = player.x - canvas.width / 3;
            if (gameState.camera.x < 0) gameState.camera.x = 0;
            const maxCameraX = Math.max(0, currentGoal.x + currentGoal.width + 50 - canvas.width);
            if (gameState.camera.x > maxCameraX) gameState.camera.x = maxCameraX;
        }
        
        function updateEnemies() {
            if (gameState.gameOver || gameState.levelCompleteFlag || gameState.gameCompleteFlag) return;

            currentEnemies.forEach(enemy => {
                if (!enemy.alive) return;
                
                enemy.x += enemy.vx;
                let onPlatform = false;
                let groundY = enemy.y + enemy.height; // Default to current if no platform found

                // Simplified enemy gravity and platform interaction
                let onAnyPlatform = false;
                currentPlatforms.forEach(platform => {
                    if (enemy.x + enemy.width > platform.x && enemy.x < platform.x + platform.width) {
                        // Check if enemy is roughly above the platform
                        if (enemy.y + enemy.height >= platform.y && enemy.y + enemy.height <= platform.y + 20) {
                             enemy.y = platform.y - enemy.height;
                             onAnyPlatform = true;
                        }
                    }
                });

                // Edge detection (simplified)
                if(onAnyPlatform){
                    let checkXForward = enemy.x + (enemy.direction * (enemy.width/2 + Math.abs(enemy.vx * 5))); // Look a bit ahead
                    let foundGroundForward = false;
                    currentPlatforms.forEach(platform => {
                        if(checkXForward + enemy.width > platform.x && checkXForward < platform.x + platform.width &&
                           enemy.y + enemy.height >= platform.y && enemy.y + enemy.height <= platform.y + 20) {
                            foundGroundForward = true;
                        }
                    });
                    if(!foundGroundForward && enemy.type !== 'goomba_no_turn'){ // Goombas might not turn at edges as easily
                        enemy.vx *= -1;
                        enemy.direction *= -1;
                    }
                }
                
                // Wall collision
                currentPlatforms.forEach(platform => {
                    const nextEnemyHitbox = { x: enemy.x + enemy.vx, y: enemy.y, width: enemy.width, height: enemy.height };
                    if (checkCollision(nextEnemyHitbox, platform)) {
                        if( enemy.y + enemy.height > platform.y && enemy.y < platform.y + platform.height ) { // Vertically aligned
                            enemy.vx *= -1;
                            enemy.direction *= -1;
                        }
                    }
                });
            });
        }
        
        function takeDamage() {
            if (player.invulnerable || gameState.levelCompleteFlag || gameState.gameCompleteFlag || gameState.gameOver) return;
            
            if (player.onYoshi) {
                player.onYoshi = false;
                player.yoshiHeldEnemy = null; // Drop held enemy
                player.height = 32; // Back to Mario's height
                // Player might pop up slightly if Yoshi was taller. Adjust y.
                player.y += (48-32);

                // Find the Yoshi spawn for the current level and mark it not collected to respawn it
                // This is a simple way, could be improved (e.g. timer)
                const yoshiSpawn = currentYoshiSpawns.find(ys => ys.originalX && ys.originalY); // Assuming we add these
                if (yoshiSpawn) yoshiSpawn.collected = false; // Allow re-collection

            } else {
                gameState.lives--;
            }

            player.invulnerable = true;
            player.invulnerabilityTimer = 120;
            
            if (gameState.lives <= 0) {
                triggerGameOver();
            }
        }
        
        function respawnPlayer() {
            player.x = 100; player.y = 200;
            player.vx = 0; player.vy = 0;
            if (player.onYoshi){ // If died on Yoshi, lose Yoshi
                player.onYoshi = false;
                player.yoshiHeldEnemy = null;
                player.height = 32;
            }
            // gameState.camera.x = 0; // Or camera logic in updatePlayer will adjust
        }
        
        function triggerGameOver() {
            gameState.gameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function completeLevel() {
            if (gameState.gameOver || gameState.levelCompleteFlag || gameState.gameCompleteFlag) return;

            gameState.levelCompleteFlag = true;
            gameState.score += 1000 + (gameState.coins * 10); // Bonus

            document.getElementById('completedLevelNum').textContent = gameState.currentLevel + 1;
            document.getElementById('finalScoreLevelComplete').textContent = gameState.score;
            document.getElementById('finalCoinsLevelComplete').textContent = gameState.coins;
            document.getElementById('levelComplete').style.display = 'block';
        }

        function nextLevel() {
            gameState.currentLevel++;
            if (gameState.currentLevel >= levelData.length) {
                triggerGameComplete();
            } else {
                initializeLevel(gameState.currentLevel);
                document.getElementById('levelComplete').style.display = 'none';
            }
        }

        function triggerGameComplete() {
            gameState.gameCompleteFlag = true;
            document.getElementById('finalScoreGameComplete').textContent = gameState.score;
            document.getElementById('levelComplete').style.display = 'none'; // Hide level complete if shown
            document.getElementById('gameComplete').style.display = 'block';
        }
        
        function initializeLevel(levelIndex) {
            gameState.levelCompleteFlag = false;
            gameState.gameCompleteFlag = false;
            gameState.gameOver = false; // Ensure game over is reset if restarting from there
            
            const level = levelData[levelIndex];
            currentPlatforms = JSON.parse(JSON.stringify(level.platforms)); // Deep copy
            currentCoins = level.coins.map(c => ({ ...c, width: 16, height: 16, collected: false }));
            currentEnemies = level.enemies.map(e => ({
                ...e, x: e.originalX, y: e.y, vx: e.originalVX, direction: e.originalVX > 0 ? 1 : -1, 
                alive: true, width: e.type === 'goomba' ? 20 : 24, height: e.type === 'goomba' ? 16 : 24
            }));
            currentYoshiSpawns = level.yoshiSpawns.map(ys => ({ ...ys, originalX: ys.x, originalY: ys.y, collected: false})); // Store original pos
            currentGoal = { ...level.goal, reached: false };

            spatEnemies = []; // Clear spat enemies
            player.yoshiHeldEnemy = null; // Clear held enemy
            yoshiTongue.active = false; // Reset tongue

            // Reset player state for new level
            player.x = 100; player.y = 200; player.vx = 0; player.vy = 0;
            player.grounded = false;
            if (player.onYoshi) { // If player had Yoshi from previous level, remove for new level start (optional)
                 player.onYoshi = false; player.height = 32;
            }
            
            gameState.camera.x = 0;
            document.getElementById('levelDisplay').textContent = gameState.currentLevel + 1;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('levelComplete').style.display = 'none';
            document.getElementById('gameComplete').style.display = 'none';
        }

        function restartGame(fromBeginning) {
            if(fromBeginning){
                gameState.currentLevel = 0;
                gameState.score = 0;
                gameState.lives = 3;
                gameState.coins = 0;
            } else { // Restart current level
                gameState.lives--; // Penalty for restarting level unless it's a fresh R press
                if (gameState.lives <= 0) {
                    triggerGameOver();
                    return; // Don't initialize if game over
                }
            }
            player.invulnerable = false; // Reset invulnerability
            initializeLevel(gameState.currentLevel);
             if (!gameState.gameOver) { // Start game loop if not game over
                gameLoop();
            }
        }
        
        function drawPlayer() {
            ctx.save();
            if (player.invulnerable && Math.floor(player.invulnerabilityTimer / 5) % 2) ctx.globalAlpha = 0.5;
            
            const x = player.x - gameState.camera.x;
            const y = player.y;
            
            if (player.onYoshi) {
                // Yoshi Body (Green)
                ctx.fillStyle = '#32CD32'; // Yoshi Green
                ctx.fillRect(x, y + 10, player.width, player.height - 10); // Main body
                // Yoshi Head
                ctx.beginPath();
                ctx.arc(x + player.width * (player.direction > 0 ? 0.8 : 0.2), y + 15, 10, 0, Math.PI * 2);
                ctx.fill();
                // Yoshi Eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x + player.width * (player.direction > 0 ? 0.85 : 0.15), y + 12, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(x + player.width * (player.direction > 0 ? 0.87 : 0.13), y + 12, 2, 0, Math.PI * 2);
                ctx.fill();
                // Yoshi Legs (simple animation)
                ctx.fillStyle = '#228B22'; // Darker Green
                if (player.grounded && Math.abs(player.vx) > 0.1) {
                    if (player.animFrame === 0) {
                        ctx.fillRect(x + 4, y + player.height - 6, 6, 6);
                        ctx.fillRect(x + player.width - 10, y + player.height - 8, 6, 8); // Trailing leg higher
                    } else {
                        ctx.fillRect(x + 4, y + player.height - 8, 6, 8);
                        ctx.fillRect(x + player.width - 10, y + player.height - 6, 6, 6);
                    }
                } else {
                     ctx.fillRect(x + 4, y + player.height - 6, 6, 6);
                     ctx.fillRect(x + player.width - 10, y + player.height - 6, 6, 6);
                }

                // Mario on Yoshi (smaller)
                const marioX = x + player.width / 2 - 8; // Center Mario on Yoshi
                const marioY = y; // Mario sits on top
                ctx.fillStyle = '#FF0000'; ctx.fillRect(marioX + 3, marioY + 4, 6, 8); // Shirt
                ctx.fillStyle = '#0066CC'; ctx.fillRect(marioX + 2, marioY + 8, 8, 6); // Overalls
                ctx.fillStyle = '#FFDBAC'; ctx.fillRect(marioX + 4, marioY + 1, 4, 4); // Head
                ctx.fillStyle = '#8B4513'; ctx.fillRect(marioX + 3, marioY, 6, 2);   // Hair

                // Held enemy in mouth visual
                if (player.yoshiHeldEnemy) {
                    ctx.fillStyle = player.yoshiHeldEnemy.type === 'turtle' ? '#228B22' : '#A52A2A'; // Turtle shell or Goomba color
                    let mouthX = x + (player.direction > 0 ? player.width : -player.yoshiHeldEnemy.width/2);
                    let mouthY = y + 12;
                    ctx.fillRect(mouthX, mouthY, player.yoshiHeldEnemy.width/2, player.yoshiHeldEnemy.height/2);
                }

            } else { // Regular Mario
                ctx.fillStyle = '#FF0000'; ctx.fillRect(x + 6, y + 8, 12, 16);
                ctx.fillStyle = '#0066CC'; ctx.fillRect(x + 4, y + 16, 16, 12);
                ctx.fillStyle = '#FFDBAC'; ctx.fillRect(x + 8, y + 2, 8, 8); 
                ctx.fillStyle = '#8B4513'; ctx.fillRect(x + 6, y, 12, 4);
                ctx.fillStyle = '#8B4513';
                if (Math.abs(player.vx) > 0.1 && player.grounded) {
                    if (player.animFrame < 2) { ctx.fillRect(x + 2, y + 28, 6, 4); ctx.fillRect(x + 16, y + 28, 6, 4); }
                    else { ctx.fillRect(x + 4, y + 28, 6, 4); ctx.fillRect(x + 14, y + 28, 6, 4); }
                } else { ctx.fillRect(x + 4, y + 28, 6, 4); ctx.fillRect(x + 14, y + 28, 6, 4); }
            }
            ctx.restore();
        }

        function drawYoshiTongue() {
            if (!yoshiTongue.active) return;
            ctx.fillStyle = 'red';
            let tongueDrawX = yoshiTongue.x - gameState.camera.x;
            if (yoshiTongue.direction < 0) {
                tongueDrawX = yoshiTongue.x - yoshiTongue.currentLength - gameState.camera.x;
            }
            ctx.fillRect(tongueDrawX, yoshiTongue.y, 
                         yoshiTongue.direction > 0 ? yoshiTongue.currentLength : yoshiTongue.currentLength, 
                         yoshiTongue.height);
        }

        function drawSpatEnemies() {
            spatEnemies.forEach(spat => {
                if (!spat.alive) return;
                // Use general enemy draw logic for spat items
                drawEnemy(spat); // We'll need to adapt drawEnemy to take an object
            });
        }
        
        function drawPlatforms() {
            currentPlatforms.forEach(platform => {
                const x = platform.x - gameState.camera.x; const y = platform.y;
                if (x + platform.width < 0 || x > canvas.width) return;
                if (platform.type === 'ground') {
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(x, y, platform.width, platform.height);
                    ctx.fillStyle = '#228B22'; ctx.fillRect(x, y, platform.width, 8);
                } else if (platform.type === 'platform') {
                    ctx.fillStyle = '#D2691E'; ctx.fillRect(x, y, platform.width, platform.height);
                    ctx.fillStyle = '#F4A460'; ctx.fillRect(x, y, platform.width, 4);
                } else if (platform.type === 'skybar') {
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(x, y, platform.width, platform.height);
                    ctx.fillStyle = '#FFFF99'; ctx.fillRect(x, y, platform.width, 3);
                }
            });
        }
        
        function drawCoins() {
            currentCoins.forEach(coin => {
                if (coin.collected) return;
                const x = coin.x - gameState.camera.x; const y = coin.y;
                if (x + coin.width < 0 || x > canvas.width) return;
                const time = Date.now() / 200; const scale = Math.abs(Math.sin(time));
                ctx.fillStyle = '#FFD700'; ctx.fillRect(x + coin.width/2 - coin.width*scale/2, y, coin.width*scale, coin.height);
                ctx.fillStyle = '#FFFF99'; ctx.fillRect(x + coin.width/2 - coin.width*scale/2, y, coin.width*scale, 4);
            });
        }

        function drawYoshiSpawns() {
            currentYoshiSpawns.forEach(yoshi => {
                if (yoshi.collected) return;
                const x = yoshi.x - gameState.camera.x; const y = yoshi.y;
                if (x + yoshi.width < 0 || x > canvas.width) return;
                // Draw Yoshi Egg
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(x + yoshi.width / 2, y + yoshi.height / 2, yoshi.width / 2, yoshi.height / 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#32CD32'; // Green spots
                ctx.beginPath(); ctx.arc(x + yoshi.width * 0.5, y + yoshi.height * 0.3, 5, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + yoshi.width * 0.3, y + yoshi.height * 0.6, 4, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(x + yoshi.width * 0.7, y + yoshi.height * 0.7, 4, 0, Math.PI*2); ctx.fill();
            });
        }
        
        function drawEnemy(enemy) { // Generic enemy draw function
            const x = enemy.x - gameState.camera.x;
            const y = enemy.y;
             if (x + enemy.width < 0 || x > canvas.width) return;

            if (enemy.type === 'turtle') {
                ctx.fillStyle = '#228B22'; ctx.fillRect(x + 2, y + 4, 20, 16); // Shell
                ctx.fillStyle = '#32CD32'; ctx.fillRect(x + 4, y + 6, 16, 4); // Highlight
                ctx.fillStyle = '#90EE90'; // Skin
                ctx.fillRect(x + (enemy.direction > 0 ? 18 : 0), y + 8, 6, 8); // Head
                ctx.fillStyle = '#000000'; ctx.fillRect(x + (enemy.direction > 0 ? 20 : 2), y + 10, 2, 2); // Eyes
                ctx.fillStyle = '#90EE90'; // Legs
                const legOffset = Math.floor(Date.now() / 200) % 2 === 0 ? 0 : 2;
                ctx.fillRect(x + 6 + legOffset, y + 20, 3, 4); ctx.fillRect(x + 15 - legOffset, y + 20, 3, 4);
            } else if (enemy.type === 'goomba') {
                ctx.fillStyle = '#A0522D'; // Brown body
                ctx.beginPath();
                ctx.moveTo(x, y + enemy.height);
                ctx.lineTo(x + enemy.width / 2, y);
                ctx.lineTo(x + enemy.width, y + enemy.height);
                ctx.closePath();
                ctx.fill();
                // Feet
                ctx.fillStyle = '#D2B48C'; // Tan
                ctx.fillRect(x + 2, y + enemy.height - 4, 4, 4);
                ctx.fillRect(x + enemy.width - 6, y + enemy.height - 4, 4, 4);
                // Eyes
                ctx.fillStyle = 'white';
                ctx.fillRect(x + 4, y + 4, 4, 4);
                ctx.fillRect(x + enemy.width - 8, y + 4, 4, 4);
                ctx.fillStyle = 'black';
                ctx.fillRect(x + 5 + (enemy.direction > 0 ? 1:0), y + 5, 2, 2);
                ctx.fillRect(x + enemy.width - 7 + (enemy.direction > 0 ? 1:0), y + 5, 2, 2);
            }
        }

        function drawEnemies() {
            currentEnemies.forEach(enemy => {
                if (!enemy.alive) return;
                drawEnemy(enemy);
            });
        }

        function drawGoal() {
            const goal = currentGoal;
            const x = goal.x - gameState.camera.x; const y = goal.y;
            if (x + goal.width < 0 || x > canvas.width) return;
            ctx.fillStyle = '#A9A9A9'; ctx.fillRect(x + goal.width / 2 - 5, y, 10, goal.height);
            ctx.fillStyle = goal.reached ? '#FF4500' : '#32CD32';
            let flagY = y + 10; if(goal.reached) flagY = y + goal.height - 30 -10; // Move flag down if reached
            ctx.beginPath(); ctx.moveTo(x + goal.width / 2 + 5, flagY);
            ctx.lineTo(x + goal.width / 2 + 5 + 30, flagY + 15); 
            ctx.lineTo(x + goal.width / 2 + 5, flagY + 30); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(x + goal.width / 2, y, 8, 0, Math.PI * 2); ctx.fill();
        }
        
        function drawBackground() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 15; i++) {
                const cloudBaseX = 200 + i * 400; // Wider spacing for more clouds
                const parallaxFactor = 0.3 + (i%3 * 0.05); // Vary parallax slightly
                let x = (cloudBaseX - gameState.camera.x * parallaxFactor);
                const screenLoopWidth = canvas.width / (1-parallaxFactor) + 200; 
                x = (x % screenLoopWidth + screenLoopWidth) % screenLoopWidth - 100; // Ensure positive and wraps
                const y = 50 + Math.sin(i) * 20 + (i%4 * 25);
                if (x > -100 && x < canvas.width + 50) {
                    ctx.beginPath(); ctx.arc(x, y, 20 + (i%2*5) , 0, Math.PI * 2);
                    ctx.arc(x + 25, y + (i%2*5), 25 + (i%3*5), 0, Math.PI * 2);
                    ctx.arc(x + 50, y, 20 + (i%2*5), 0, Math.PI * 2); ctx.fill();
                }
            }
        }
        
        function render() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#5C94FC'); gradient.addColorStop(1, '#B8E8FF');
            ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawBackground(); drawPlatforms(); drawGoal(); 
            drawCoins(); drawYoshiSpawns();
            drawEnemies(); drawSpatEnemies(); 
            drawPlayer(); drawYoshiTongue();
        }
        
        function updateHUD() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('coins').textContent = gameState.coins;
        }
        
        let lastTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;

            if(deltaTime >= frameInterval || !lastTime) { // Ensure running at target FPS
                lastTime = timestamp - (deltaTime % frameInterval);

                if (!gameState.gameOver && !gameState.levelCompleteFlag && !gameState.gameCompleteFlag) {
                    handleInput();
                    updatePlayer();
                    updateEnemies();
                    updateYoshiTongue();
                    updateSpatEnemies();
                }
                render();
                updateHUD();
            }
            
            // Always request next frame unless game is truly over or explicitly stopped
            if (!gameState.gameOver && !gameState.gameCompleteFlag) { // Continue loop if level complete to show screen
                 requestAnimationFrame(gameLoop);
            } else if (gameState.gameOver || gameState.gameCompleteFlag) {
                // Final render for game over/complete screen and stop
                render(); 
                updateHUD();
            }
        }
        
        initializeLevel(gameState.currentLevel);
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>